<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="generator" content="Aspose.Words for .NET 25.7.0" /><title></title><style type="text/css">body { font-family:Calibri; font-size:11pt }h1, h3, h4, p { margin:0pt 0pt 8pt }li { margin-top:0pt; margin-bottom:8pt }h1 { margin-top:12pt; margin-bottom:3pt; page-break-after:avoid; font-family:Arial; font-size:16pt; font-weight:bold }h3 { margin-top:12pt; margin-bottom:3pt; page-break-after:avoid; font-family:Arial; font-size:13pt; font-weight:bold }h4 { margin-top:12pt; margin-bottom:3pt; page-break-after:avoid; font-size:14pt; font-weight:bold }.Quote { margin-bottom:8pt; border-left:2.25pt solid #9f9f9f; font-size:11pt; font-style:italic; color:#000000; -aw-style-name:quote }span.QuoteChar { font-size:12pt; font-style:italic; color:#000000 }</style></head><body><div><h1><span style="font-family:Calibri; font-weight:normal">看起来你提供了一篇关于</span><span style="font-weight:normal">“</span><span style="font-family:Calibri; font-weight:normal">错误捕获内存（</span><span style="font-weight:normal">ECR</span><span style="font-family:Calibri; font-weight:normal">）</span><span style="font-weight:normal">”</span><span style="font-family:Calibri; font-weight:normal">的详细技术文档，但没有具体的问题需要我解答呢。你是想让我对这篇文档进行润色、提取关键信息、根据文档进行某种计算或分析吗？请告诉我你的具体需求哦。</span></h1><h3><span style="font-weight:normal">1.11 </span><span style="font-family:Calibri; font-weight:normal">错误捕获内存（</span><span style="font-weight:normal">ECR</span><span style="font-family:Calibri; font-weight:normal">）</span></h3><p><span>参见站点装配板框图、错误捕获内存软件。</span></p><p><span>错误捕获内存（ECR）可作为选件，用于从正在执行的 uRAM 模式中实时捕获每个引脚、每个周期、每个被测器件（DUT）的失效引脚信息。捕获数据的典型应用包括：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>存储器测试冗余分析（MfdRA）。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>存储器测试位图支持，即位图工具（BitmapTool）。</span></p><p><span>本节包含以下内容：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>概述</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>ECR 数据宽度、特殊数据宽度</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>ECR 地址折叠</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>ECR 三维到二维地址映射</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>ECR 错误计数器</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>ECR 迷你内存（Mini-RAM）</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>RCM：可配置行、列或迷你内存</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>ECR 地址拓扑逻辑</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>ECR 顺序模式</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>ECR 绝对写入模式</span></p><h4><span style="font-weight:normal">1.11.1 概述</span></h4><p><span>参见站点装配板框图、错误捕获内存软件。</span></p><p><span>如上所述，错误捕获内存（ECR）可作为选件，用于从正在执行的 uRAM 模式中实时捕获每个引脚、每个周期、每个被测器件（DUT）的失效引脚信息。捕获数据的典型应用包括：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>存储器测试冗余分析（MfdRA）。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>存储器测试位图支持，即位图工具（BitmapTool）。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>逻辑错误捕获（LEC）。</span></p><p><span>主要特性：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>在单数据速率（SDR）模式下，ECR 失效捕获速率最高可达 428MHz（参见 ECR 容量与 DIMM 分配、ECR 容量：1 个 DIMM 模块分配、ECR 容量：2 个 DIMM 模块分配、ECR 容量：4 个 DIMM 模块分配）。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>支持双数据速率（DDR），ECR 失效捕获速率最高可达 856MHz。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>支持 MUX / 超级 MUX 模式，ECR 失效捕获速率最高可达 856MHz。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>支持 DDR+MUX / 超级 MUX 组合模式。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>ECR 数据宽度：1、2、4、8、16、32、64、128 引脚，以及 3 种针对 DRAM 测试的特殊数据宽度（参见 ECR 数据宽度、特殊数据宽度）。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>支持 X+Y+Z 地址字段（参见 ECR 三维到二维地址映射）。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>每个站点配备 128 位线错误计数器（I/O 错误计数器）。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>每个被测器件（DUT）的总错误计数器，每个站点最多支持 32 个 DUT。可通过测试模式进行保存 / 清零，且可能影响测试模式分支操作。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>ECR 迷你内存（ECR Mini-RAM），支持面向块或段的器件测试。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>64 位 RCM：可配置为行、列或迷你内存，可灵活设置为行错误捕获内存、列错误捕获内存或 2 个迷你内存。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>基于总错误计数器的测试模式实时条件分支。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>支持 ECR 地址折叠，当被测器件（DUT）包含必须测试的备用行和备用列且需将错误捕获到 ECR 时，可减少 ECR 的使用量。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>ECR 顺序模式。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>ECR 同时捕获与扫描（SCS）。</span></p><p><span>下图展示了每个 Magnum V 站点上错误捕获内存（ECR）的硬件实现（简化版）：</span></p><p><span>（图 66：Magnum V ECR 架构，简化版）</span></p><p><span>需要注意的是，Magnum V 的 ECR 架构与 Magnum 2/2x 有很大差异，主要区别包括：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>在 ECR 使用场景中，Magnum V 的被测器件（DUT）引脚与测试仪通道的连接规则简单：任何 DUT 引脚均可连接到任何测试仪通道。这一点也适用于基于 DUT 的测试模式分支规则。</span></p><p><span>下图进一步描述了 Magnum V ECR 架构的更多细节：</span></p><p><span>（图 67：Magnum V ECR 框图）</span></p><p><span>注意以下几点：</span></p><p><span>算法模式发生器（APG）向 ECR 地址拓扑逻辑输出 24 位 X、16 位 Y、16 位 Z 地址以及 8 位可配置为 Y 或 Z 地址的位。这构成了一个三维地址空间。然而，ECR 必须在二维内存空间中运行，因此用户需要将 APG 的 X、Y、Z 地址映射到 ECR 的 X' 和 Y' 地址，这通过 ECR 三维到二维地址映射宏实现（参见 ECR 三维到二维地址映射）。</span></p><p><span>主 ECR 内存采用突发 DRAM 实现，可安装 1 个或 2 个 DIMM 模块（标准配置）或 4 个 DIMM 模块（选件，详见下文）。一个站点装配板上的所有 4 个站点配置相同。每个站点上，前 2 个 DIMM 模块为通用 DIMM，可用于 ECR、逻辑向量内存（LVM）或数据缓冲内存（DBM）。可选的 2 个 DIMM 模块仅可用于 ECR。</span></p><p><span>测试程序中使用 DIMM_ASSIGNMENTS 宏分配 DIMM 模块给 ECR、LVM 和 DBM（参见共享内存配置（DIMM 分配））。使用标准站点装配板时，可分配 1 个或 2 个 DIMM 给 ECR 使用（这会影响可分配给 LVM 和 DBM 的 DIMM 数量）。Magnum V 有第二种成本更高的站点装配板设计（称为 HSBex 选件），包含 2 个额外的 DIMM 模块和一个额外的 FPGA 内存控制器，仅可作为 ECR 内存使用。使用 HSBex 选件时，可分配 0、1、2 或 4 个 DIMM 给 ECR 使用（这会影响可分配给 LVM 和 DBM 的 DIMM 数量）。</span></p><p><span>目前可用的 DIMM 模块容量仅为 32Gbit，这些 DIMM 可用于 ECR、DBM 和 LVM。下表显示了不同 DIMM 分配情况下的最大 ECR 容量：</span></p><p><span>（表 1.11.1.0-1：ECR 容量与 DIMM 分配）</span></p><p><span>如上所述，主 ECR 内存采用突发 DRAM 实现。通过交错技术，ECR 的错误捕获速率可超过所使用 DRAM 的原生写入速度。错误捕获内存（ECR）的最大错误捕获速率取决于以下因素：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>分配给 ECR 使用的 DIMM 数量（参见上文及共享内存配置（DIMM 分配））。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>测试程序中通过传递给 ecr_config_set () 的 EcrConfigStruct 中的 fastest_cycle 参数指定的最大 ECR 捕获速率。ECR 的正常运行要求被捕获到 ECR 的引脚上的实际选通速率不超过该值。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>测试程序中通过传递给 ecr_config_set () 的 EcrConfigStruct 中的 seq_length 参数指定的 ECR 捕获序列长度（参见 ECR 顺序模式了解详细信息和重要规则）。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>系统软件根据上述 fastest_cycle 值和 seq_length 值计算的交错比。</span></p><p><span>交错比为 1 时，可获得最大的有效 ECR 容量。一般来说，提高捕获速率（fastest_cycle）和 / 或缩短捕获序列长度（seq_length）需要增大交错比，这可能会减小 ECR 的有效容量；反之，降低捕获速率和 / 或增加捕获序列长度可减小交错比，可能会增大 ECR 的有效容量。需要注意的是，使用 DDR 测试模式和 / 或配置为 MUX 模式或超级 MUX 模式的引脚不会改变这一点，因为每个测试仪周期捕获的额外错误会占用其他引脚的 ECR 内存（参见 ECR 与 DDR 和 / 或 MUX / 超级 MUX）。</span></p><p><span>Magnum V 支持的 ECR 捕获速率、序列长度和交错比取决于分配给 ECR 的 DIMM 模块数量（通过 DIMM_ASSIGNMENTS 设置）。使用标准站点装配板时，可分配 0、1 或 2 个 DIMM 模块给 ECR；使用可选的 HSBex 站点装配板时，可分配 0、1、2 或 4 个 DIMM 模块。以下 3 个表格显示了在不同捕获速率、序列长度和交错比下的有效 ECR 容量（均基于 32Gbit DIMM 模块，若未来有更大容量模块，这些值将按比例调整）。</span></p><p><span>（表 1.11.1.0-2：ECR 容量：1 个 DIMM 模块分配）</span></p><p><span>（表 1.11.1.0-3：ECR 容量：2 个 DIMM 模块分配）</span></p><p><span>（表 1.11.1.0-4：ECR 容量：4 个 DIMM 模块分配）</span></p><p><span>关于上述表格，请注意以下几点：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>当仅分配 1 个 DIMM 模块时，428MHz 仅在 group_width≤64 时可用，其中：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:' '; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="-aw-import:spaces">&#xa0;</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>group_width = ECR 数据宽度 × DUT 数量 × 数据速率模式</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:' '; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="-aw-import:spaces">&#xa0;</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>ECR 数据宽度是 EcrConfigStruct 中的 datawidth 参数，等于 EcrConfigStruct 参数 datapins 的指定值。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:' '; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="-aw-import:spaces">&#xa0;</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>DUT 数量是 ECRConfigStruct 的 dut_number_set 参数值。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:' '; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="-aw-import:spaces">&#xa0;</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>数据速率模式是 ECRConfigStruct 的 mode 参数值，属于枚举类型 EcrDdrMuxMode：</span></p><p style="margin-left:72pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:1; -aw-list-number-format:'o'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">o</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>对于 SDR：data_rate_mode = 1</span></p><p style="margin-left:72pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:1; -aw-list-number-format:'o'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">o</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>对于 DDR 或 MUX：data_rate_mode = 2</span></p><p style="margin-left:72pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:1; -aw-list-number-format:'o'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">o</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>对于 DDR+MUX：data_rate_mode = 4</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>随着分配给 ECR 的 DIMM 模块数量增加，有效 ECR 容量增大，最大捕获速率选项增多，支持的交错比数值也增多。然而，与 2 个 DIMM 配置相比，使用可选的 HSBex 站点装配板并分配 4 个 DIMM 模块给 ECR 并不会提高最大捕获速率或减小最小序列长度，但能实现全速（即序列长度 = 1）、随机访问（即非交错）的错误捕获。当分配 2 个 DIMM 给 ECR 并使用随机地址捕获错误（即序列长度 = 1）时，最大捕获速率将限制在 296MHz；在此配置下，要实现全速捕获（即非交错），序列长度至少为 2。因此，如上表最后一项所述，唯一能实现全速、随机访问错误捕获的配置是将 HSBex 站点装配板的所有 4 个 DIMM 模块分配给 ECR。</span></p><p><span>ECR 地址拓扑逻辑提供独立的 X 与 Y 拓扑 scrambling 逻辑，以及 5 位 X 到 Y 和 Y 到 X 的地址映射功能。Z 地址没有独立的拓扑逻辑（但 Z 地址位可作为 X 和 / 或 Y 拓扑逻辑的输入）。ECR 地址拓扑逻辑仅在捕获错误时使用，即在从 ECR 扫描（读取）错误时不使用。该逻辑允许对用于读写 DUT 的地址和用于捕获错误到 ECR 的地址应用不同的 APG 地址拓扑 scrambling。例如，可采用块快速地址方案测试 DUT，同时采用线性寻址将错误捕获到 ECR。这实际上是通过 ECR 地址拓扑逻辑解除（线性化）应用于 DUT 的拓扑 scrambling。由于 ECR 的扫描（读取）始终是线性的，因此可提高 ECR 的扫描效率。由于 APG 地址发生器的地址拓扑和 ECR 的地址拓扑采用相同的硬件设计，相关硬件描述集中在一处：参见 ECR 地址拓扑逻辑；软件 / 配置信息参见 APG 地址 / 数据与 ECR 地址拓扑配置。需要注意的是，与 Magnum 1 不同，Magnum 2 不使用 ECR 地址 scramble 内存，因此 Magnum 1 上使用的相关 API 函数在 Magnum 2x 上无效。</span></p><p><span>ECR 地址交叉点用于选择在记录错误到 ECR 和统计总错误计数器（TEC）时使用的 X/Y 地址，还提供地址压缩功能，即一个或多个 X 和 / 或 Y 地址位在寻址 ECR 时不被使用（忽略等）。这实际上会导致一定范围的地址被捕获到 ECR 的同一位置。X 和 Y 地址压缩通过 ecr_config_set () 的两个参数进行配置，当前的地址压缩配置可通过 ecr_config_get () 获取。需要注意的是，使用 ECR 地址压缩可能会影响配置 ECR 地址拓扑逻辑时使用的表达式（参见 APG 地址 / 数据与 ECR 地址拓扑配置）。</span></p><p><span>ECR 数据交叉点用于选择哪些测试仪通道映射到特定的 DUT，其配置基于测试程序中的 DUT 数量和配置 ECR 时指定的数据引脚（通过 ecr_config_set ()）。正确配置的前提是用户遵循 DUT 引脚与测试仪引脚的连接要求。</span></p><p><span>ECR 数据选择与压缩逻辑用于选择哪些 DUT 引脚被捕获到主 ECR 内存、由总错误计数器（TEC）统计以及由 I/O 错误计数器统计，还提供数据压缩功能，即将多个引脚的错误捕获到 ECR 的同一 bit，由同一个 TEC 统计等。该逻辑通过 ecr_config_set () 间接配置，可通过 ecr_config_get () 获取配置的引脚列表。</span></p><p><span>ECR 迷你内存用于测试面向块或段的存储器件时，获取主 ECR 内存的压缩视图（参见 ECR 迷你内存）。迷你内存地址交叉点确定在记录错误到 ECR 迷你内存和进行地址压缩时使用的地址，通过 ecr_miniram_config_set () 间接配置。</span></p><p><span>RCM（可配置行、列或迷你内存）可通过软件配置为多种模式，只要配置符合其地址位的大小限制（20 位或 21 位），包括但不限于：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>行错误捕获内存</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>列错误捕获内存</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>第二个迷你内存。与主 ECR 迷你内存每个地址存储 1 个 bit 不同，它可为多达 64 个可选数据位存储独立的错误。</span></p><p><span>（参见 RCM：可配置行、列或迷你内存和 ECR 迷你内存）</span></p><p><span>下图展示了错误如何记录到主 ECR 内存，以及当 RCM 配置为行内存或列内存时（两者互斥，或 RCM 也可配置为第二个迷你内存，参见 RCM：可配置行、列或迷你内存）的情况：</span></p><p><span>（图 68：带行或列内存的 ECR 主内存）</span></p><p><span>如上所示，行内存和列内存互斥，仅当 RCM 配置为行内存或列内存时存在（参见 RCM：可配置行、列或迷你内存）。</span></p><h4><span style="font-weight:normal">1.11.2 ECR 数据宽度、特殊数据宽度</span></h4><p><span>参见错误捕获内存（ECR）、错误捕获内存软件。</span></p><p><span>Magnum V 错误捕获内存（ECR）从用户指定的引脚列表中捕获错误，该引脚列表通过传递给 ecr_config_set () 的 EcrConfigStruct 中的 datapins 参数指定。</span></p><p><span>该引脚列表中的引脚数量决定了 ECR 的数据宽度，默认情况下，当引脚数量不是 2 的幂时，会向上取最近的 2 的幂；即与 Magnum 1/2/2x 不同，Magnum V 不支持 9、18 或 36 的数据宽度，支持的标准 ECR 数据宽度为 1、2、4、8、16、32、64 和 128。</span></p><p><span>Magnum V 错误捕获内存（ECR）架构还支持 3 种特殊数据宽度：10、20 和 40 引脚（这些在 Magnum 1/2/2x 上不支持）。</span></p><p><span>这些特殊数据宽度在测试 LPDDR2、DDR2 和 DDR3 DRAM 时可能有用。例如，使用 10 位数据宽度时，8 位用于常规读写数据，另外 2 位用于 DQS 引脚或就绪 / 忙引脚；20 位数据宽度支持 16 位数据引脚和 4 位 DQS 或就绪 / 忙引脚；40 位数据宽度支持 32 位数据引脚和 8 位 DQS 或就绪 / 忙引脚。此外，10 位、20 位和 40 位数据宽度也可分别支持 10、20 或 40 位的读写数据。</span></p><p><span>在 Magnum V 中，默认情况下，ecr_config_set () 的 datapins 参数指定的引脚数量决定了 ECR 数据宽度的配置。要启用特殊数据宽度，需将 special_width 参数（在 EcrConfigStruct 中）设置为以下选项之一。</span></p><p><span>启用特殊数据宽度时，错误在主 ECR 内存中的存储（打包）方式与非特殊数据宽度不同，这会影响每个站点可测试的最大 DUT 数量，如下表所示（全捕获模式和二进制捕获模式下的值相同）：</span></p><p><span>（表 1.11.2.0-1：支持的 DUT 数量与 ECR 特殊数据宽度）</span></p><p><span>启用特殊数据宽度时，ECR 错误计数器只能配置为重复模式，即 ecr_counters_config_set () 的各种模式参数可为 t_address_duplicates 和 t_bit_duplicates。因此，不支持 t_address_no_dups 和 t_bit_no_dups 模式，指定这些模式会产生警告。</span></p><p><span>每种特殊数据宽度有两种捕获模式：全捕获和二进制捕获（为便于参考，下文还描述了标准配置）。以下以 10 位数据宽度为例说明这些模式：</span></p><ol type="1" style="margin:0pt; padding-left:0pt"><li style="margin-left:31.35pt; padding-left:4.65pt"><span>默认情况下，当 ecr_config_set () 的 datapins 参数包含 10 个引脚，且 special_width 参数为 t_special_dw_na（默认值，参见 EcrConfigStruct）时，ECR 配置为 16 位数据宽度（即二进制数据宽度边界），但仅从指定的 10 个数据引脚捕获错误。这是标准配置。若启用，错误会由 ECR 错误计数器统计，每个 DUT 的错误累加到一个 TEC 计数器中。</span></li><li style="margin-left:31.35pt; padding-left:4.65pt"><span>使用相同的 10 引脚 datapins 列表，若 special_width 参数设置为 t_dw10_full_capture（参见 EcrConfigStruct），则 ECR 配置为特殊的 10 位数据宽度。所有 10 个数据引脚的错误都会被捕获到 ECR 中，但每个 DUT 使用 2 个 TEC 计数器：</span></li></ol><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>数据引脚 7:0 的错误累加到一个 TEC 计数器。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>引脚 8/9 的错误累加到第二个 TEC 计数器。</span></p><ol type="1" style="margin:0pt; padding-left:0pt"><li style="margin-left:31.35pt; padding-left:4.65pt"><span>使用相同的 10 引脚 datapins 列表，若 special_width 参数设置为 t_dw10_binary_capture，则 ECR 配置为特殊的 10 位数据宽度。仅数据引脚 7:0 的错误被捕获到 ECR 中（引脚 8/9 的错误不被捕获）。每个 DUT 使用 2 个 TEC 计数器：</span></li></ol><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>数据引脚 7:0 的错误累加到一个 TEC 计数器。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>引脚 8/9 的错误累加到第二个 TEC 计数器。</span></p><p><span>下表将上述 10 位特殊数据宽度的配置扩展到其他特殊数据宽度：</span></p><p><span>（表 1.11.2.0-2：ECR 特殊数据宽度配置）</span></p><h4><span style="font-weight:normal">1.11.3 ECR 地址折叠</span></h4><p><span>（内容待补充）</span></p><h4><span style="font-weight:normal">1.11.4 ECR 三维到二维地址映射</span></h4><p><span>参见错误捕获内存（ECR）、ECR 三维到二维地址映射宏。</span></p><p><span>算法模式发生器（APG）向 ECR 地址拓扑逻辑输出 24 位 X、16 位 Y、16 位 Z 地址以及 8 位可配置为 Y 或 Z 地址的位，构成三维地址空间。但 ECR 内部必须在二维内存空间中运行，因此当 uRAM 模式使用 Z 地址时，用户需指定如何将三维 X、Y、Z 地址转换（映射）为二维 X'+Y' 地址，这通过 ECR 三维到二维地址映射宏实现。</span></p><p><span>ECR 三维到二维地址映射分两步执行：</span></p><ol type="1" style="margin:0pt; padding-left:0pt"><li style="margin-left:31.35pt; padding-left:4.65pt"><span>使用 ECR_XY_TOPO_MAP_CLEAR () 宏清除现有映射。初始加载测试程序时会定义默认映射，因此这一步始终是必需的。</span></li><li style="margin-left:31.35pt; padding-left:4.65pt"><span>使用 ECR 三维到二维地址映射宏指定新的映射。</span></li></ol><p><span>注意：如前所述，ECR 软件仅在 X/Y ECR 地址的上下文中报告错误，即用户必须理解所应用的任何 ECR 三维到二维地址映射，才能推导出 APG 施加到 DUT 的实际 X/Y/Z 地址。</span></p><h4><span style="font-weight:normal">1.11.5 ECR 错误计数器</span></h4><p><span>参见错误捕获内存（ECR）。</span></p><p><span>如 Magnum V ECR 框图所示，ECR 有两组错误计数器：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>总错误计数器（TEC）：39 位计数器，用于统计总失效位或总失效地址的数量（参见 ecr_counters_config_set ()）。在多 DUT 测试程序中，每个 DUT 有独立的 TEC（每个站点最多 32 个）。使用 ECR 特殊数据宽度时，某些配置每个 DUT 使用 2 个总错误计数器（TEC），参见 ECR 数据宽度、特殊数据宽度。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>I/O 错误计数器（IOC）：35 位计数器，用于统计每个 ECR 数据输入的错误数量。每个站点有 128 个 I/O 计数器。在多 DUT 测试程序中，这些计数器在 DUT 之间平均分配，如下表所示：</span></p><p><span>（表 1.11.5.0-1：ECR I/O 计数器分布）</span></p><p><span>ECR 错误计数器通过 ecr_counters_config_set () 配置，当前配置可通过 ecr_counters_config_get () 获取。可通过 ecr_error_counter_get () 读取指定计数器的值，通过 ecr_error_counter_set () 修改计数器的值，通过 ecr_all_clear () 和 ecr_counters_clear () 清除计数器，ecr_config_set () 也会清除这些计数器。</span></p><p><span>在执行测试模式时，可通过 MAR CLEARERR 指令清除计数器，该指令会立即将计数器重置为 0，并开始统计新的错误。但测试模式的基于错误的分支逻辑需要 38 个额外的模式周期才能感知到计数器值的变化。</span></p><p><span>每个总错误计数器（TEC）都有一个对应的硬件比较器。当对应的 TEC 计数器值超过指定计数时，TEC 比较器向测试模式分支错误选择逻辑发送 TRUE 信号，可用于控制 uRAM 模式中的分支操作（参见基于错误的分支逻辑和 MAR 错误选择操作数）。</span></p><p><span>当使用计数器 / 比较器控制分支操作时，用户的测试模式必须满足基于错误的分支和 RESET 流水线要求。由于 APG 流水线架构，TEC 计数器值的变化可能需要几个模式周期才能到达 APG 的基于错误的分支逻辑（参见基于错误的分支和 RESET 流水线要求）。此外，若分支操作导致模式执行停止（MAR DONE），这些必要的流水线周期可能会继续统计错误，若在模式执行结束后读取 TEC 计数器（使用 ecr_error_counter_get ()），会看到这些错误。</span></p><p><span>总错误计数器（TEC）和 I/O 错误计数器各有一组。执行 ECR 同时捕获和扫描（SCS）时，这些计数器始终与用于捕获错误的 ECR 部分关联，因此不能用于辅助扫描操作。使用 ECR 同时捕获和扫描（SCS）时，若错误捕获到 ECR 区域 1，随后切换到 ECR 区域 2 进行捕获，ECR 的错误计数器会继续统计错误，除非在捕获到区域 2 之前显式清除计数器。</span></p><p><span>在 Magnum 2、Magnum 2x 和 Magnum V 中，可在测试模式执行期间将总错误计数器（TEC）的值多次保存到计算机内存中（参见总错误计数器（TEC），从测试模式保存）。每次保存后，TEC 会被清除并立即开始统计新的错误。该过程可根据需要重复（直到站点控制器内存耗尽）。模式执行结束后，用户代码可检索保存的计数器值进行分析。典型应用是将 TEC 用作块或段错误计数器：用户设计的测试模式一次为一个块 / 段生成 X/Y 地址，在每个块或段测试完成时保存当前的 TEC 值。模式执行结束后，用户编写的代码可检索并分析保存的 TEC 值，作为块 / 段错误计数。</span></p><h4><span style="font-weight:normal">1.11.6 ECR 迷你内存</span></h4><p><span>参见错误捕获内存（ECR）。</span></p><p><span>如 Magnum V ECR 框图所示，ECR 包含 ECR 迷你内存，用于获取主 ECR 内存的压缩视图。硬件上，迷你内存是 16K 的内存，每个地址为每个 DUT 存储 1 个 bit。Magnum V 每个站点最多支持 32 个 DUT。</span></p><p><span>迷你内存的目标应用是获取记录到主 ECR 内存的错误的块或段导向视图。由于迷你内存是主 ECR 内存的 [可能高度] 压缩版本，可用于快速确定主 ECR 内存的大面积区域是否存在错误。具有冗余资源的器件通常有备用行和 / 或列，当 DUT 有备用段或块时，迷你内存最为有用。</span></p><p><span>注意以下几点：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>使用前，必须通过 ecr_miniram_config_set () 配置迷你内存，且必须在通过 ecr_config_set () 配置 ECR 之后进行。硬件上，这会配置迷你内存地址交叉点和迷你内存数据选择与压缩逻辑。可通过 ecr_miniram_config_get () 函数获取当前的迷你内存配置。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>模式执行期间，错误会同时记录到主 ECR 内存、迷你内存和 RCM（可配置行、列或迷你内存）。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>模式执行结束后，可使用 ecr_miniram_scan () 函数扫描迷你内存，确定主 ECR 内存的每个范围（通常对应一个段或块）捕获到错误的位置。扫描迷你内存比扫描主 ECR 内存快得多，用于识别哪些段或块存在错误。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>可通过 ecr_miniram_read () 读取迷你内存，通过 ecr_miniram_write () 修改迷你内存，通过 ecr_all_clear ()、ecr_rams_clear () 以及可选的 ecr_area_clear () 清除迷你内存。注意 ecr_config_set () 也会清除迷你内存。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>在多 DUT 测试程序中，每个 DUT 有独立的迷你内存。</span></p><h4><span style="font-weight:normal">1.11.7 RCM：可配置行、列或迷你内存</span></h4><p><span>参见 RCM：可配置行、列或迷你内存、错误捕获内存（ECR）、RCM 函数。</span></p><p><span>RCM 是可配置行、列或迷你内存的缩写，是一种硬件选件，提供可配置的内存，接收来自 RCM 地址交叉点的 X/Y 地址和来自 RCM 数据选择与压缩逻辑的错误（参见 Magnum V ECR 框图）。RCM 还可用作数字源 / 捕获（DSC）的 DSC 源和 DSC 捕获内存。</span></p><p><span>RCM 可配置为多种模式，包括：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>行错误捕获内存</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>列错误捕获内存</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>第二个迷你内存。与主 ECR 迷你内存不同，每个地址可为多达 64 个可选数据位存储独立的错误，而 ECR 迷你内存每个地址存储 1 个 bit。</span></p><p><span>每个站点只有一个 RCM，其容量不足以同时使用所有 24 位 X + 24 位 Y 地址。支持的配置如下：</span></p><p><span>（表 1.11.7.0-1：RCM 配置选项）</span></p><p><span>每种配置中 RCM 的有效容量取决于：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>安装的 RCM 内存选件的容量。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>测试的 DUT 数量：RCM 在与 ECR 关联的所有 DUT 之间分区共享。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>每个 DUT 捕获的数据线数量。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>使用的数据压缩比（若有），参见 ecr_rcm_config_set ()。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>经 RCM 地址压缩调整后的 DUT X/Y 地址大小，参见 ecr_rcm_config_set ()。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>RCM 的配置模式（行内存、列内存或迷你内存），参见 ecr_rcm_config_set ()：配置为行内存时，仅 X 地址位路由到 RCM；配置为列内存时，仅 Y 地址位路由到 RCM；配置为迷你内存时，同时使用 X 和 Y 地址。</span></p><p><span>如前所述，通过使用地址和 / 或数据压缩，可增大 RCM 的有效容量：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>地址压缩减少 RCM 必须处理的地址位数。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>数据压缩减少存储每个 DUT 错误所需的内存量。</span></p><p><span>RCM、ECR 迷你内存和主 ECR 内存各有独立的数据压缩逻辑，因此 RCM 既可以作为主 ECR 内存的压缩版本，也可以不使用数据压缩，不仅能指示 DUT 地址范围内是否存在错误，还能指示该范围内哪些数据引脚存在错误。</span></p><p><span>模式执行前，必须通过 ecr_rcm_config_set () 配置 RCM，通过 ecr_rcm_config_get () 函数可检索当前的 RCM 配置。</span></p><p><span>可通过 ecr_rcm_ram_write () 向 RCM 显式写入数据，通过 ecr_rcm_ram_read () 从 RCM 读取数据，通过 ecr_rcm_ram_scan () 扫描 RCM 中的错误。</span></p><p><span>无论配置如何，模式执行期间，ECR 记录错误时，都会同时将错误记录到当前 [压缩] 地址的 RCM 中（参见带行或列内存的 ECR 主内存）。模式执行结束后，可使用 RCM 和 / 或 ECR 迷你内存提高 ECR 的读取（扫描）性能，使扫描程序能够跳过 RCM 中没有错误的行、列或地址。</span></p><p><span>注意：将必须修复过滤（MRF）与锐化过滤器结合使用时，RCM 的内容会被破坏（参见 MRF 过滤器选项）。但由于锐化过滤器选项不能与冗余分析（MfdRA）一起使用，因此这很少成为问题。</span></p><h4><span style="font-weight:normal">1.11.8 ECR 地址拓扑逻辑</span></h4><p><span>参见 APG 地址发生器、APG 地址 / 数据与 ECR 地址拓扑配置。</span></p><p><span>注意：尽管本节与 APG 地址拓扑逻辑部分非常相似，但两者存在关键差异，因此需要分别文档化，包括 APG 地址 / 数据与 ECR 地址拓扑配置部分。</span></p><p><span>错误捕获内存（ECR）包含用于执行地址拓扑 scrambling 的逻辑，即把算法模式发生器（APG）生成的逻辑地址转换为正确测试 DUT 所需的拓扑地址（参见逻辑地址与物理地址、电气地址）。</span></p><p><span>（图 69：ECR X 地址逻辑）</span></p><p><span>（图 70：ECR Y 地址逻辑）</span></p><p><span>（图 71：ECR Z 地址逻辑）</span></p><p><span>使用地址拓扑 scrambling 只需配置拓扑逻辑，详情参见 APG 地址 / 数据与 ECR 地址拓扑配置。</span></p><p><span>默认情况下，模式执行期间，24 位 X、Y 和 Z 地址通过 ECR 地址拓扑逻辑时不发生改变。用户代码可选择配置拓扑逻辑（参见 APG 地址 / 数据与 ECR 地址拓扑配置），根据各种地址属性和逻辑操作修改 X 和 / 或 Y（而非 Z）地址。在上图中，X 交叉多路复用器允许任意 5 个 Y 和 / 或 Z 地址位影响 X 地址拓扑 scrambling，反之亦然。</span></p><p><span>注意：本节其余部分仅涉及 ECR 的 X 地址拓扑 scrambling，Y 地址电路与之相同（关于 X/Y/Z 地址输入具有互补性）。X 和 Y 地址拓扑 scrambling 电路不共享下图所示的任何组件。</span></p><p><span>（图 72：地址拓扑 scramble 简化框图）</span></p><p><span>全局操作</span></p><p><span>每个 ECR 地址拓扑的全局操作块包含该拓扑的 24 个每 bit 操作块共享的逻辑，主要组件包括：</span></p><p><span>（图 73：ECR X 地址拓扑 scramble 全局操作框图）</span></p><p><span>注意以下几点：</span></p><p><span>ECR X 地址拓扑逻辑的全局操作块接收以下输入：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>X 地址发生器输出的 24 位 X 地址，这些地址位在模式执行期间可能每个周期都发生变化。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>通过 X 交叉多路复用器从 Y 和 / 或 Z 地址发生器选择的最多 5 个地址交叉位，具体选择的位在模式执行前通过 set_xvr () 显式设置或通过 xvr [] 自动设置（但不在掩码中）。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>4 个 29 位掩码寄存器值，在模式执行前设置（参见拓扑掩码和拓扑配置宏）。拓扑掩码可用于根据最多 4 个用户定义的地址拓扑掩码影响拓扑 scrambling。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>2 个存储体选择值，在模式执行前通过拓扑配置宏设置。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>24 位偏移值，通过 set_offset () 在模式执行前设置，由地址 + 偏移发生器与当前 X 地址相加。每个每 bit 操作块可单独选择该偏移地址的 1 个 bit，以影响该每 bit 操作块的输出。</span></p><p><span>全局操作块的输出是所有 24 个每 bit 操作块的共享输入，用于生成 24 位拓扑 scrambling 后的输出地址位：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>4 个掩码选择和 2 个存储体选择信号。掩码信号是动态的 1 位掩码寄存器输出信号，在给定的模式周期中，当当前 X 地址加上最多 5 个选定的 Y 和 / 或 Z 交叉地址位与该掩码选择的值匹配时，掩码输入为 TRUE。4 个掩码选择信号由所有 24 个每 bit 块共享。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>地址 + 偏移发生器输出的 25 位，包括 24 位地址 + 偏移信号和偏移加法的进位位。使用地址 + 偏移发生器输出时，每个每 bit 操作块选择其中的 1 个 bit。</span></p><p><span>每 bit 操作</span></p><p><span>24 个每 bit 操作块共同生成发送到 ECR 地址逻辑的 24 位拓扑 scrambling 地址位。</span></p><p><span>下图展示了其中一个 24 位块的关键组件，所有 24 个块相同，除了底部输入到拓扑逻辑的单个地址位（标记为 self）：</span></p><p><span>（图 74：ECR 地址拓扑 scramble 每 bit 操作框图）</span></p><p><span>每个每 bit 拓扑逻辑的输入包括：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>4 个掩码选择信号。掩码用于基于最多 4 个用户定义的地址拓扑掩码影响拓扑 scrambling。在给定的模式周期中，当当前 X 地址加上最多 5 个选定的 Y 和 / 或 Z 交叉地址位与该掩码选择的值匹配时，给定的掩码输入为 TRUE。4 个掩码选择信号由所有 24 个每 bit 块共享。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>2 个存储体选择信号，由所有 24 个每 bit 块共享。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>从全局操作块中地址 + 偏移发生器（带进位）输出的 25 位中选择的 1 个 bit，在图中标记为偏移。第 25 位是 X 地址与偏移相加的进位位。每个每 bit 拓扑逻辑块从地址 + 偏移（带进位）值中选择 1 个 bit，所选的 bit 通过拓扑表达式和子表达式中的 offset [] 运算符设置。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>从 24 位 X 地址位加上最多 5 个通过 X 交叉多路复用器选择的 Y 和 / 或 Z 交叉地址位（交叉位）中选择的 1 个 bit，在图中标记为 AddrBit。所选的 bit 通过拓扑表达式和子表达式中的 in [] 和 xvr [] 运算符确定。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>1 个 bit，标记为 Self，是与正在配置的输出位对应的未修改地址位。不需要拓扑 scrambling 时，该位直接通过拓扑逻辑输出。</span></p><p><span>如前所述，默认情况下 ECR 地址拓扑 scrambling 禁用。APG 地址 / 数据与 ECR 地址拓扑配置描述了如何配置拓扑硬件以启用地址拓扑 scrambling。</span></p><h4><span style="font-weight:normal">1.11.9 ECR 顺序模式</span></h4><p><span>参见错误捕获内存（ECR）、ecr_config_set ()。</span></p><p><span>ECR 顺序模式使用硬件 ECR 错误缓冲区（详见下文）以全速累积错误，但对 X/Y/Z 寻址有限制。简单来说，在 ECR 顺序模式下，ECR 锁存每个多周期地址序列的高位地址部分，仅允许低位地址位任意变化以确定 ECR 捕获错误的位置。每个序列期间，引脚错误以全速捕获到 ECR 错误缓冲区中，序列结束时，缓冲区中的数据写入主 ECR 内存，随后可开始新的序列（使用不同的高位 X/Y/Z 地址等）。</span></p><p><span>下图用于描述 ECR 顺序模式的详细操作，示例假设：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>numx () = 12（使用 12 位 X 地址）</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>numy () = 10（使用 10 位 Y 地址）</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>ecr_config_set () 的 seq_length 参数 = 8。</span></p><p><span>在此示例中，如下所示，低位 3 个地址位可在每个 ECR 地址序列期间变化，高位地址（10 位 Y 地址和高位 9 位 X 地址）在整个序列期间必须保持不变（详见下文）：</span></p><p><span>（图中展示了序列长度 = 8=3 位，如 ecr_config_set () 的 seq_length 参数所设置。每个序列期间仅 3 个最低有效位可变化）</span></p><p><span>ECR 顺序模式通过将 ecr_config_set () 的 seq_length 参数设置为&gt; 1 的值启用。ECR 错误缓冲区的深度由 seq_length 值决定（$2^{seq_length}$），同时也决定了给定地址序列期间可变化的低位地址位数（上例中为 X0、X1 和 X2）。</span></p><p><span>模式执行期间，测试模式中生成的第一个选通启动第一个 ECR 地址序列。测试模式中，通过 MAR READ、READUDATA、READV 和 READZ 中的任意一个生成选通。第一个选通：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>使 ECR 将该周期发生的任何引脚错误捕获到 ECR 错误缓冲区中，缓冲区位置由低位地址位（上例中的 X2、X1 和 X0）确定。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>递增 ECR 的序列计数器（详见下文）。</span></p><p><span>随后，每个生成选通的模式周期：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>递增 ECR 的序列计数器。也可通过 MAR ECR_SEQ_FLUSH 操作数递增计数器，当不适合使用选通但需要递增 ECR 序列计数器时使用。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>将引脚错误捕获到 ECR 错误缓冲区中，地址由低位地址位确定，低位地址位可任意变化，作为 ECR 错误缓冲区的索引。通常，序列中的每个选通周期，这些低位地址位应发生变化。若一个序列中某个低位地址被选通多次，错误会按逻辑 OR 运算存入错误缓冲区的同一地址。</span></p><p><span>当选通周期将 ECR 的序列计数器递增到与 ecr_config_set () 的 seq_length 参数指定的值匹配时，序列结束。在该周期中，ECR 锁存高位地址位，将错误缓冲区的数据写入主 ECR 内存，并清除错误缓冲区（删除所有引脚错误）。注意，实际上有 2 个 ECR 错误缓冲区，允许一个缓冲区写入主 ECR 内存并清除，同时另一个缓冲区获取错误，该操作对用户透明。</span></p><p><span>注意：当 ecr_config_set () 的 seq_length 参数为任何&gt; 1 的值时，算法模式发生器（APG）生成并施加到 DUT 的高位地址位在每个序列的最后一个周期被 ECR 锁存。这意味着 APG 地址发生器在 DUT 上生成的高位地址序列可能与用于捕获 ECR 错误的地址序列不同。这种情况下，错误可能会被记录到与从 DUT 读取的地址不同的 ECR 地址中，这是绝对不允许的！用户有责任确保在顺序模式（即 seq_length&gt;1）下用于将错误捕获到 ECR 的任何测试模式在 DUT 上生成正确的相同地址。</span></p><p><span>当 ecr_config_set () 的 wr_mode 参数为 t_abs_write 时，给定地址序列中 ECR 错误缓冲区的某个地址可能不包含错误，原因如下，这一点很重要：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>该地址没有产生引脚错误（正常操作）。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>一个序列中某个低位地址被选通多次，每次发生这种情况，另一个低位地址不会被选通，将保留其先前的值（默认无错误）。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>使用 MAR ECR_SEQ_FLUSH 操作数递增 ECR 序列计数器，每次操作会导致 ECR 错误缓冲区中的一个地址无法捕获错误。</span></p><p><span>Magnum V ECR 设计支持序列长度为 1（即随机寻址）、2、4、8、16、32、64 和 128，如下表所示，这会影响每个捕获速率所需的交错比。实际上，交错比每降低一半，有效 ECR 容量就会增加一倍。序列长度和 ECR 速率均可编程。</span></p><p><span>（表 1.11.9.0-1：Magnum V ECR 交错比与捕获速率）</span></p><p><span>该表表明，若使用 128 的地址序列测试 DUT，可在全速捕获时获得最大的有效 ECR 容量。</span></p><p><span>上表的颜色说明如下：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>2 个 DIMM 或 4 个 DIMM，或组宽度≤64（1 个 DIMM）</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>2 个 DIMM 或 4 个 DIMM</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>仅 4 个 DIMM</span></p><p><span>其中：</span></p><p><span>组宽度 = ECR 数据宽度 × DUT 数量 × 数据速率模式</span></p><p><span>ECR 数据宽度是 EcrConfigStruct 中的 datawidth 参数，等于 EcrConfigStruct 参数 datapins 的指定值，可取 1、2、4、8、16、32、64、128。</span></p><p><span>DUT 数量是 ECRConfigStruct 的 dut_number_set 参数值，可取 1、2、4、8、16、32。</span></p><p><span>数据速率模式是 ECRConfigStruct 的 mode 参数值，属于枚举类型 EcrDdrMuxMode：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>单数据速率（SDR）：data_rate_mode = 1</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>双数据速率（DDR）或 MUX：data_rate_mode = 2</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>DDR + MUX：data_rate_mode = 4</span></p><h4><span style="font-weight:normal">1.11.10 ECR 绝对写入模式</span></h4><p><span>参见错误捕获内存（ECR）。</span></p><p><span>从 6.20 版本开始，ECR 支持绝对写入模式。在此上下文中，ECR 有两种捕获模式：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>累积模式</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>绝对写入模式</span></p><p><span>ECR 写入模式通过 ecr_config_set () 的参数指定。</span></p><p><span>模式执行期间，当读取 / 选通某个 DUT 地址时，若任何引脚失效，会生成引脚错误并记录到 ECR 的对应地址中。在累积模式下，读取某个 DUT 地址时，新的错误会与该地址先前捕获的错误按逻辑 OR 运算存入 ECR。这允许在多次测试同一 DUT 地址（甚至使用多个测试模式）时累积错误，这在 DUT 有冗余电路时通常是理想的，可通过在多个 / 不同测试模式（每个模式设计用于测试不同的失效模式）执行期间累积错误来识别不良的 DUT 地址。所有模式执行结束后，ECR 包含不良位、行、列、块 / 段等的图像，随后用于分析以确定最佳的冗余修复策略。然而，累积模式还要求在测试每个新 DUT 之前显式清除 ECR，清除时无论地址内容如何，每个地址都会被写入 0x0（无错误），这需要时间。</span></p><p><span>在绝对写入模式下，模式执行期间写入某个 ECR 地址时，其内容会被新的错误数据完全替换，实际上相当于先清除该地址，再添加新的错误。这种模式下，无需为每个新 DUT 显式清除 ECR，但存在以下限制和规则：</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>Magnum 1 不支持绝对写入模式。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>仅当交错计数 = 1 时，才支持绝对写入模式（参见错误捕获内存（ECR））。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>绝对写入模式仅适用于主 ECR 内存，不影响迷你内存或 RCM（这是合理的，因为迷你内存和 RCM 的目的是累积多个 DUT 地址的错误）。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>对于传统的 ECR 应用，必须写入每个 ECR 地址。相反，任何未写入的 ECR 地址将包含旧的 / 过期的（未定义）数据。记住，绝对写入模式的目的是节省清除 ECR 的时间，若某个地址未写入新数据 / 错误，将包含旧数据 / 错误。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>若某个 ECR 地址被多次写入，仅保留最后一次写入的数据 / 错误。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>若某个 ECR 地址被多次写入，迷你内存和 RCM 的内容将无法准确反映主 ECR 内存的当前状态（这正是迷你内存和 RCM 的用途）。对同一 ECR 地址的第二次写入可能比前一次的错误更少或不同，而迷你内存和 RCM 中的错误将反映该地址所有写入操作的错误。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>扫描 ECR 时，仅需扫描或读取实际写入的地址，其他地址将包含旧的 / 过期的（未定义）数据 / 错误。</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>使用绝对写入模式时，无需显式清除主 ECR 内存（这是该模式的目的）。但绝对写入模式不改变迷你内存和 / 或 RCM 的操作，若要使用它们，必须显式清除（参见 ecr_all_clear ()）。</span></p><p><span>这些限制强调用户有责任管理绝对写入模式：必须确保仅扫描或读取实际写入的 ECR 地址。此外，由于迷你内存和 RCM（以及错误计数器）没有绝对写入模式，用户仍需在捕获前清除这些内存。不过，由于这些内存比主内存小得多，因此不会有太大的性能损失。</span></p><p class="Quote"><span style="font-style:normal">（注：文档部分内容可能由 AI 生成）</span></p></div></body></html>